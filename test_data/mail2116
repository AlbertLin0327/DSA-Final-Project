From: Jean
Date: 3 June 2012 at 22:23
Message-ID: 2116
Subject: rm (Unix) 
To: Venus
Content:
rm (short for remove) is a basic UNIX command used to remove objects such as files, directories, device nodes, symbolic links, and so on from the filesystem. To be more precise, rm removes references to objects from the filesystem, where those objects might have had multiple references (for example, a file with two different names), and the objects themselves are discarded only when all references have been removed and no programs still have open handles to the objects. This allows for scenarios where a program can open a file, immediately remove it from the filesystem, and then use it for temporary space, knowing that the file's space will be reclaimed after the program exits, even if it exits by crashing. rm generally does not destroy file data, since its purpose is really merely to unlink references, and the filesystem space freed may still contain leftover data from the removed file. This can be a security concern in some cases, and hardened versions sometimes provide for wiping out the data as the last link is being cut, and programs such as shred are available which specifically provide data wiping capability. To remove a file named "foo" from a directory one could type: Normally, no output is produced by rm, since it typically only generates messages in the event of an error. The -v option can be used to get rm to detail successful removal actions. Users concerned about removing files unexpectedly - particularly when using wildcards - sometimes use the -i option to cause rm to verify each removal in advance, although this method has its own problems.[clarification needed] rm is generally only seen on UNIX-derived operating systems, which typically do not provide for recovery of deleted files through a mechanism like the recycle bin.,[1] hence the tendency for users to enclose rm in some kind of wrapper to limit accidental file deletion. There are undelete utilities that will attempt to reconstruct the index and can bring the file back if the parts were not reused. Common options that rm accepts include: rm is often overlain by a C shell alias or Bourne shell function of "rm -i" so as to avoid accidental deletion of files. If a user still wishes to delete a large number of files without confirmation, they can manually cancel out the -i argument by adding the -f option (as the option specified later on the expanded command line "rm -i -f" takes precedence). Unfortunately this approach generates dangerous habits towards the use of wildcarding, leading to its own version of accidental removals. rm -rf (variously, rm -rf /, rm -rf *, and others) is frequently used in jokes and anecdotes about Unix disasters[2] . The rm -rf variant of the command, if run by a superuser on the root directory, would cause the contents of nearly every writable mounted filesystem on the computer to be deleted, up to the point the system itself crashes from missing some crucial file, directory, or the like. rm is often used in conjunction with xargs to supply a list of files to delete: Or, to remove all PNG images in all directories below the current one: Usually, on most filesystems, deleting a file requires write permission on the parent directory (and execute permission, in order to enter the directory in the first place). (Note that, confusingly for beginners, permissions on the file itself are irrelevant. However, GNU rm asks for confirmation if a write-protected file is to be deleted, unless the -f option is used.) To delete a directory (with rm -r), one must delete all of its contents recursively. This requires that one must have read and write and execute permission to that directory (if it's not empty) and all non-empty subdirectories recursively (if there are any). The read permissions are needed to list the contents of the directory in order to delete them. This sometimes leads to an odd situation where a non-empty directory cannot be deleted because one doesn't have write permission to it and so cannot delete its contents; but if the same directory were empty, one would be able to delete it. If a file resides in a directory with the sticky bit set, then deleting the file requires one to be the owner of the file. Sun Microsystems introduced "rm -rf /" protection in Solaris 10, first released in 2005. Upon executing the command, the system now reports that the removal of / is not allowed.[3] Shortly after, the same functionality was introduced into FreeBSD version of rm utility. GNU rm refuses to execute rm -rf / if the --preserve-root option is given, which has been the default since version 6.4 of GNU Core Utilities was released in 2006. Systems administrators, designers, and even users often attempt to defend themselves against accidentally deleting files by creating an alias or function along the lines of: Unfortunately, this tends to train users to be careless about the wildcards they hand into their rm commands, as well as encouraging a tendency to alternately pound y and the return key to affirm removes - until just past the one file they needed to keep. Users have even been seen going as far as "yes | rm files". A compromise that allows users to confirm just once, encourages proper wildcarding, and makes verification of the list easier can be achieved with something like: It's important to note that this function should not be made into a shell script, which would run a risk of it being found ahead of the system rm in the search path, nor should it be allowed in non-interactive shells where it could break batch jobs. Enclosing the definition in the if [ -n "$PS1" ]; then .... ; fi construct protects against the latter. There exist third-party wrappers that prevent accidental deletion of important files, like "safe-rm".[4]
I read the paragraph on http://wikipedia.org
