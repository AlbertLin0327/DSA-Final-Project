From: Alfred
Date: 12 May 2012 at 23:37
Message-ID: 4123
Subject: Monoid 
To: Joe
Content:
In abstract algebra, a branch of mathematics, a monoid is an algebraic structure with a single associative binary operation and an identity element. Monoids are studied in semigroup theory as they are naturally semigroups with identity. Monoids occur in several branches of mathematics; for instance, they can be regarded as categories with a single object. Thus, they capture the idea of function composition within a set. Monoids are also commonly used in computer science, both in its foundational aspects and in practical programming. The transition monoid and syntactic monoid are used in describing finite state machines, whereas trace monoids and history monoids provide a foundation for process calculi and concurrent computing. Some of the more important results in the study of monoids are the Krohn-Rhodes theorem and the star height problem. The history of monoids, as well as a discussion of additional general properties, are found in the article on semigroups. A monoid is a set, S, together with a binary operation  (pronounced "dot" or "times") that satisfies the following three axioms: And in mathematical notation we can write these as More compactly, a monoid is a semigroup with an identity element. It can also be thought of as a magma with associativity and identity. A monoid with invertibility property is a group. The symbol for the binary operation is commonly omitted; for example the monoid axioms require (ab)c = a(bc) and ea=ae=a. This does not necessarily mean the variables are numbers being multiplied, any operation or elements may be used if they are well defined. A submonoid of a monoid M is a subset N of M containing the unit element, and such that, if x,y  N then x  y  N. It is then clear that N is itself a monoid, under the binary operation induced by that of M. Equivalently, a submonoid is a subset N such that N=N*, where the superscript * is the Kleene star: the set is closed under composition or concatenation of its elements. For any subset N of M, the monoid N* is the smallest monoid that contains N. A subset N is said to be a generator of M if and only if M=N*. If there is a finite generator of M, then M is said to be finitely generated. A monoid whose operation is commutative is called a commutative monoid (or, less commonly, an abelian monoid). Commutative monoids are often written additively. Any commutative monoid is endowed with its algebraic preordering , defined by x  y if and only if there exists z such that x + z = y. An order-unit of a commutative monoid M is an element u of M such that for any element x of M, there exists a positive integer n such that x  nu. This is often used in case M is the positive cone of a partially ordered abelian group G, in which case we say that u is an order-unit of G. A monoid for which the operation is commutative for some, but not all elements is a trace monoid; trace monoids commonly occur in the theory of concurrent computation. Moreover, f can be considered as a function on the points \{0,1,2,\dots,n-1\} given by or, equivalently Multiplication of elements in \langle f\rangle is then given by function composition. Note also that when k = 0 then the function f is a permutation of \{0,1,2,\dots,n-1\} and gives the unique cyclic group of order n. In a monoid, one can define positive integer powers of an element x: x1=x, and xn=x*...*x (n times) for n>1 . The rule of powers xn+p=xn * xp is obvious. Directly from the definition, one can show that the identity element e is unique. Then, for any x, one can set x0=e and the rule of powers is still true with nonnegative exponents. It is possible to define invertible elements: an element x is called invertible if there exists an element y such that x*y = e and y*x = e. The element y is called the inverse of x . If y and z are inverses of x, then by associativity y = (zx)y = z(xy) = z. Thus inverses, if they exist, are unique.[3] If y is the inverse of x, one can define negative powers of x by setting x1=y and xn=y*...*y (n times) for n>1 . And the rule of exponents is still verified for all n,p rational integers. This is why the inverse of x is usually written x1. The set of all invertible elements in a monoid M, together with the operation *, forms a group. In that sense, every monoid contains a group (if only the trivial one consisting of the identity alone). However, not every monoid sits inside a group. For instance, it is perfectly possible to have a monoid in which two elements a and b exist such that a*b = a holds even though b is not the identity element. Such a monoid cannot be embedded in a group, because in the group we could multiply both sides with the inverse of a and would get that b = e, which isn't true. A monoid (M,*) has the cancellation property (or is cancellative) if for all a, b and c in M, a*b = a*c always implies b = c and b*a = c*a always implies b = c. A commutative monoid with the cancellation property can always be embedded in a group via the Grothendieck construction. That's how the additive group of the integers (a group with operation +) is constructed from the additive monoid of natural numbers (a commutative monoid with operation + and cancellation property). However, a non-commutative cancellative monoid need not be embeddable in a group. If a monoid has the cancellation property and is finite, then it is in fact a group. Proof: Fix an element x in the monoid. Since the monoid is finite, xn = xm for some m > n > 0. But then, by cancellation we have that xm-n = e where e is the identity. Therefore x * xm-n-1 = e, so x has an inverse. The right- and left-cancellative elements of a monoid each in turn form a submonoid (i.e. obviously include the identity and not so obviously are closed under the operation). This means that the cancellative elements of any commutative monoid can be extended to a group. An inverse monoid is a monoid where for every a in M, there exists a unique a1 in M such that a=a*a1*a and a1=a1*a*a1. If an inverse monoid is cancellative, then it is a group. Let M be a monoid, with the binary operation denoted by  and the identity element denoted by e. Then a (left) M-act (or left act over M) is a set X together with an operation : M  X  X which is compatible with the monoid structure as follows: This is the analogue in monoid theory of a (left) group action. Right M-acts are defined in a similar way. A monoid with an act is also known as an operator monoid. Important examples include transition systems of semiautomata. A transformation semigroup can be made into an operator monoid by adjoining the identity transformation. A homomorphism between two monoids (M,*) and (M,) is a function f: M  M such that where e and e are the identities on M and M respectively. Monoid homomorphisms are sometimes simply called monoid morphisms. Not every semigroup homomorphism is a monoid homomorphism since it may not preserve the identity. Contrast this with the case of group homomorphisms: the axioms of group theory ensure that every semigroup homomorphism between groups preserves the identity. For monoids this isn't always true and it is necessary to state it as a separate requirement. A bijective monoid homomorphism is called a monoid isomorphism. Two monoids are said to be isomorphic if there is an isomorphism between them. Monoids may be given a presentation, much in the same way that groups can be specified by means of a group presentation. One does this by specifying a set of generators , and a set of relations on the free monoid . One does this by extending (finite) binary relations on  to monoid congruences, and then constructing the quotient monoid, as above. Given a binary relation R    , one defines its symmetric closure as R  R1. This can be extended to a symmetric relation E     by defining x ~E y if and only if x = sut and y = svt for some strings u, v, s, t   with (u,v)  R  R1. Finally, one takes the reflexive and transitive closure of E, which is then a monoid congruence. In the typical situation, the relation R is simply given as a set of equations, so that R=\{u_1=v_1,\cdots,u_n=v_n\}. Thus, for example, is the equational presentation for the bicyclic monoid, and is the plactic monoid of degree 2 (it has infinite order). Elements of this plactic monoid may be written as a^ib^j(ba)^k for integers i, j, k, as the relations show that ba commutes with both a and b. Monoids can be viewed as a special class of categories. Indeed, the axioms required of a monoid operation are exactly those required of morphism composition when restricted to the set of all morphisms whose source and target is a given object. That is, More precisely, given a monoid (M,*), one can construct a small category with only one object and whose morphisms are the elements of M. The composition of morphisms is given by the monoid operation *. Likewise, monoid homomorphisms are just functors between single object categories. So this construction gives an equivalence between the category of (small) monoids Mon and a full subcategory of the category of (small) categories Cat. Similarly, the category of groups is equivalent to another full subcategory of Cat. In this sense, category theory can be thought of as an extension of the concept of a monoid. Many definitions and theorems about monoids can be generalised to small categories with more than one object. For example, a quotient of a category with one object is just a quotient monoid. Monoids, just like other algebraic structures, also form their own category, Mon, whose objects are monoids and whose morphisms are monoid homomorphisms. There is also a notion of monoid object which is an abstract definition of what is a monoid in a category. A monoid object in Set is just a monoid. In computer science, many abstract data types can be endowed with a monoid structure. In a common pattern, a sequence of elements of a monoid is "folded" or "accumulated" to produce a final value. For instance, many iterative algorithms need to update some kind of "running total" at each iteration; this pattern may be elegantly expressed by a monoid operation. Alternatively, the associativity of monoid operations ensures that the operation can be parallelized by employing a prefix sum or similar algorithm, in order to utilize multiple cores or processors efficiently. Given a sequence of values of type M with identity element \varepsilon and associative operation *, the fold operation is defined as follows: In addition, any data structure can be 'folded' in a similar way, given a serialization of its elements. For instance, the result of "folding" a binary tree might differ depending on pre-order vs. post-order tree traversal.
I read the paragraph on http://wikipedia.org
